// Generated by CoffeeScript 1.9.1
(function() {
  var CatchAllMessage, EnterMessage, Listener, Response, TextListener, TextMessage, User, chai, expect, ref, ref1, sinon;

  chai = require('chai');

  sinon = require('sinon');

  chai.use(require('sinon-chai'));

  expect = chai.expect;

  ref = require('../src/message'), CatchAllMessage = ref.CatchAllMessage, EnterMessage = ref.EnterMessage, TextMessage = ref.TextMessage;

  ref1 = require('../src/listener'), Listener = ref1.Listener, TextListener = ref1.TextListener;

  Response = require('../src/response.js');

  User = require('../src/user.js');

  describe('Listener', function() {
    beforeEach(function() {
      this.robot = {
        Response: Response
      };
      return this.user = new User({
        id: 1,
        name: 'hubottester',
        room: '#mocha'
      });
    });
    return describe('Unit Tests', function() {
      describe('#call', function() {
        it('calls the matcher', function() {
          var callback, testListener, testMatcher, testMessage;
          callback = sinon.spy();
          testMatcher = sinon.spy();
          testMessage = {};
          testListener = new Listener(this.robot, testMatcher, callback);
          testListener.call(testMessage);
          return expect(testMatcher).to.have.been.calledWith(testMessage);
        });
        it('passes the matcher result on to the listener callback', function() {
          var listenerCallback, matcherResult, result, testListener, testMatcher, testMessage;
          matcherResult = {};
          testMatcher = sinon.stub().returns(matcherResult);
          testMessage = {};
          listenerCallback = function(response) {
            return expect(response.match).to.be.equal(matcherResult);
          };
          expect(matcherResult).to.be.ok;
          testListener = new Listener(this.robot, testMatcher, listenerCallback);
          result = testListener.call(testMessage);
          expect(testMatcher).to.have.been.called;
          return expect(result).to.be.ok;
        });
        describe('if the matcher returns true', function() {
          it('executes the listener callback', function() {
            var listenerCallback, testListener, testMatcher, testMessage;
            listenerCallback = sinon.spy();
            testMatcher = sinon.stub().returns(true);
            testMessage = {};
            testListener = new Listener(this.robot, testMatcher, listenerCallback);
            testListener.call(testMessage);
            return expect(listenerCallback).to.have.been.called;
          });
          it('returns true', function() {
            var listenerCallback, result, testListener, testMatcher, testMessage;
            listenerCallback = sinon.spy();
            testMatcher = sinon.stub().returns(true);
            testMessage = {};
            testListener = new Listener(this.robot, testMatcher, listenerCallback);
            result = testListener.call(testMessage);
            return expect(result).to.be.ok;
          });
          return it('calls the listener callback with a Response that wraps the Message', function(done) {
            var listenerCallback, testListener, testMatcher, testMessage;
            testMatcher = sinon.stub().returns(true);
            testMessage = {};
            listenerCallback = function(response) {
              expect(response.message).to.equal(testMessage);
              return done();
            };
            testListener = new Listener(this.robot, testMatcher, listenerCallback);
            return testListener.call(testMessage, sinon.spy());
          });
        });
        return describe('if the matcher returns false', function() {
          it('does not execute the listener callback', function() {
            var listenerCallback, testListener, testMatcher, testMessage;
            listenerCallback = sinon.spy();
            testMatcher = sinon.stub().returns(false);
            testMessage = {};
            testListener = new Listener(this.robot, testMatcher, listenerCallback);
            testListener.call(testMessage);
            return expect(listenerCallback).to.not.have.been.called;
          });
          return it('returns false', function() {
            var listenerCallback, result, testListener, testMatcher, testMessage;
            listenerCallback = sinon.spy();
            testMatcher = sinon.stub().returns(false);
            testMessage = {};
            testListener = new Listener(this.robot, testMatcher, listenerCallback);
            result = testListener.call(testMessage);
            return expect(result).to.not.be.ok;
          });
        });
      });
      return describe('TextListener', function() {
        return describe('#matcher', function() {
          it('matches TextMessages', function() {
            var callback, result, testListener, testMessage, testRegex;
            callback = sinon.spy();
            testMessage = new TextMessage(this.user, 'test');
            testMessage.match = sinon.stub().returns(true);
            testRegex = /test/;
            testListener = new TextListener(this.robot, testRegex, callback);
            result = testListener.matcher(testMessage);
            expect(result).to.be.ok;
            return expect(testMessage.match).to.have.been.calledWith(testRegex);
          });
          return it('does not match EnterMessages', function() {
            var callback, result, testListener, testMessage, testRegex;
            callback = sinon.spy();
            testMessage = new EnterMessage(this.user);
            testMessage.match = sinon.stub().returns(true);
            testRegex = /test/;
            testListener = new TextListener(this.robot, testRegex, callback);
            result = testListener.matcher(testMessage);
            expect(result).to.not.be.ok;
            return expect(testMessage.match).to.not.have.been.called;
          });
        });
      });
    });
  });

}).call(this);

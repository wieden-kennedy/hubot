// Generated by CoffeeScript 1.9.1
(function() {
  var Adapter, CatchAllMessage, EnterMessage, Robot, TextMessage, chai, expect, mockery, ref, sinon;

  chai = require('chai');

  sinon = require('sinon');

  chai.use(require('sinon-chai'));

  expect = chai.expect;

  mockery = require('mockery');

  Robot = require('../src/robot.js');

  ref = require('../src/message'), CatchAllMessage = ref.CatchAllMessage, EnterMessage = ref.EnterMessage, TextMessage = ref.TextMessage;

  Adapter = require('../src/adapter');

  mockery.enable();

  mockery.registerAllowable('hubot-mock-adapter');

  mockery.registerAllowable('lodash');

  mockery.registerMock('hubot/src/adapter', Adapter);

  require('hubot-mock-adapter');

  mockery.deregisterMock('hubot/src/adapter');

  mockery.disable();

  describe('Robot', function() {
    beforeEach(function() {
      this.robot = new Robot(null, 'mock-adapter', true, 'TestHubot');
      this.robot.run;
      return this.user = this.robot.brain.userForId('1', {
        name: 'hubottester',
        room: '#mocha'
      });
    });
    afterEach(function() {
      this.robot.server.close();
      return this.robot.shutdown();
    });
    describe('Unit Tests', function() {
      return describe('#receive', function() {
        it('calls all registered listeners', function() {
          var listener, testMessage;
          testMessage = new TextMessage(this.user, 'message123');
          listener = {
            call: sinon.spy()
          };
          this.robot.listeners = [listener, listener, listener, listener];
          this.robot.receive(testMessage);
          return expect(listener.call).to.have.callCount(8);
        });
        it('sends a CatchAllMessage if no listener matches', function() {
          var oldReceive, testMessage;
          testMessage = new TextMessage(this.user, 'message123');
          this.robot.listeners = [];
          oldReceive = this.robot.receive;
          this.robot.receive = function(message) {
            expect(message).to.be["instanceof"](CatchAllMessage);
            return expect(message.message).to.be.equal(testMessage);
          };
          sinon.spy(this.robot, 'receive');
          oldReceive.call(this.robot, testMessage);
          return expect(this.robot.receive).to.have.been.called;
        });
        it('does not trigger a CatchAllMessage if a listener matches', function() {
          var matchingListener, oldReceive, testMessage;
          testMessage = new TextMessage(this.user, 'message123');
          matchingListener = {
            call: function(message) {
              return true;
            }
          };
          oldReceive = this.robot.receive;
          this.robot.receive = sinon.spy();
          this.robot.listeners = [matchingListener];
          oldReceive.call(this.robot, testMessage);
          return expect(this.robot.receive).to.not.have.been.called;
        });
        it('stops processing if a listener marks the message as done', function() {
          var listenerSpy, matchingListener, testMessage;
          testMessage = new TextMessage(this.user, 'message123');
          matchingListener = {
            call: function(message) {
              message.done = true;
              return true;
            }
          };
          listenerSpy = {
            call: sinon.spy()
          };
          this.robot.listeners = [matchingListener, listenerSpy];
          this.robot.receive(testMessage);
          return expect(listenerSpy.call).to.not.have.been.called;
        });
        return it('gracefully handles listener uncaughtExceptions (move on to next listener)', function() {
          var badListener, goodListener, goodListenerCalled, testMessage, theError;
          testMessage = {};
          theError = new Error();
          badListener = {
            call: function() {
              throw theError;
            }
          };
          goodListenerCalled = false;
          goodListener = {
            call: function(_) {
              goodListenerCalled = true;
              return true;
            }
          };
          this.robot.listeners = [badListener, goodListener];
          this.robot.emit = function(name, err, response) {
            expect(name).to.equal('error');
            expect(err).to.equal(theError);
            return expect(response.message).to.equal(testMessage);
          };
          sinon.spy(this.robot, 'emit');
          this.robot.receive(testMessage);
          expect(this.robot.emit).to.have.been.called;
          return expect(goodListenerCalled).to.be.ok;
        });
      });
    });
    return describe('Message Processing', function() {
      it('calls a matching listener', function(done) {
        var testMessage;
        testMessage = new TextMessage(this.user, 'message123');
        this.robot.hear(/^message123$/, function(response) {
          expect(response.message).to.equal(testMessage);
          return done();
        });
        return this.robot.receive(testMessage);
      });
      it('calls multiple matching listeners', function() {
        var listenerCallback, listenersCalled, testMessage;
        testMessage = new TextMessage(this.user, 'message123');
        listenersCalled = 0;
        listenerCallback = function(response) {
          expect(response.message).to.equal(testMessage);
          return listenersCalled++;
        };
        this.robot.hear(/^message123$/, listenerCallback);
        this.robot.hear(/^message123$/, listenerCallback);
        this.robot.receive(testMessage);
        return expect(listenersCalled).to.equal(2);
      });
      it('calls the catch-all listener if no listeners match', function(done) {
        var listenerCallback, testMessage;
        testMessage = new TextMessage(this.user, 'message123');
        listenerCallback = sinon.spy();
        this.robot.hear(/^no-matches$/, listenerCallback);
        this.robot.catchAll(function(response) {
          expect(listenerCallback).to.not.have.been.called;
          expect(response.message).to.equal(testMessage);
          return done();
        });
        return this.robot.receive(testMessage);
      });
      it('does not call the catch-all listener if any listener matched', function() {
        var catchAllCallback, listenerCallback, testMessage;
        testMessage = new TextMessage(this.user, 'message123');
        listenerCallback = sinon.spy();
        this.robot.hear(/^message123$/, listenerCallback);
        catchAllCallback = sinon.spy();
        this.robot.catchAll(catchAllCallback);
        this.robot.receive(testMessage);
        expect(listenerCallback).to.have.been.called.once;
        return expect(catchAllCallback).to.not.have.been.called;
      });
      it('stops processing if message.finish() is called synchronously', function() {
        var listenerCallback, testMessage;
        testMessage = new TextMessage(this.user, 'message123');
        this.robot.hear(/^message123$/, function(response) {
          return response.message.finish();
        });
        listenerCallback = sinon.spy();
        this.robot.hear(/^message123$/, listenerCallback);
        this.robot.receive(testMessage);
        return expect(listenerCallback).to.not.have.been.called;
      });
      return it('calls non-TextListener objects', function(done) {
        var testMessage;
        testMessage = new EnterMessage(this.user);
        this.robot.enter(function(response) {
          expect(response.message).to.equal(testMessage);
          return done();
        });
        return this.robot.receive(testMessage);
      });
    });
  });

}).call(this);
